---
order: 4
---
# Outputs

Kestra's flow can produce outputs when processing tasks. Output data are stored in flow execution context and can be handled and used by tasks next to the output producer one.

You can use outputs every where [variables](/docs/developer-guide/variables/) are allowed, so it can be used as next task values for iteration or conditional processing or even as extra output content.

## Using outputs

You can declare as many outputs for any flow. Outputs context variables are stored following each task declaration.

Here how to use output between tasks into a flow:

```yaml
tasks:
- id: produce-output
  type: org.kestra.core.tasks.debugs.Return
  format: my output {{ execution.id }}
- id: use-output
  type: org.kestra.core.tasks.debugs.Echo
  format: This task display previous task output {{ outputs.produce-output.value }}
```

In the example above the first task produces an output with the format yaml property. the ouput content is then used in the second task output formating. Indeed, the `use-output` task uses the templating system <code v-pre>{{ outputs.produce-output.value }}</code> to reference the previous task output.

Using this template context variable interpolates the bracket reference with the entire output generated by the first task.

::: tip note
The `.value` in the template bracket that reach another task's output content is a value that depends on what data is produced per value. In our case, for the **Return** task, the `value` content is filled with the output. It could be `bq_table` for another task implemented for big query management. Have a look at each task documentation for specific information about what context variable are filled with ouput contents.
:::

## Dynamic variables

#### Current value
You can access the current value with <code v-pre>{{ taskrun.value }}</code> like that:

```yaml
tasks:
  - id: each
    type: org.kestra.core.tasks.flows.EachSequential
    value: '["value 1", "value 2", "value 3"]'
    tasks:
      - id: inner
        type: org.kestra.core.tasks.debugs.Return
        format: "{{task.id}} > {{taskrun.value}} > {{taskrun.startDate}}"
```

###  Specific outputs for dynamic tasks

Another more specific case for output management is the runtime generated tasks output variables. It is the case for the **EachSequential** or **EachParallel** task that produces dynamically other tasks depending on it's `value` property. In this case it is possible to reach each iteration output individually using the following syntax :

```yaml
id: output-sample
namespace: org.kestra.tests

tasks:
  - id: 1-output
    type: org.kestra.core.tasks.flows.EachSequential
    value: '["s1", "s2", "s3"]'
    tasks:
        - id: 1_1-produce_output
        type: org.kestra.core.tasks.debugs.Return
        format: "{{task.id}} > {{taskrun.value}} > {{taskrun.startDate}}"
  - id: 2_use_output
    type: org.kestra.core.tasks.debugs.Return
    format: "Previous task produced output : {{outputs.1_1-produce_output.s1.a.value}}"
```

Here the `outputs.1_1-produce_output.s1.a.value` reach the first `1-output` task element.

#### Previous task lookup
It's also possible to locate a special task by his `value`:
```yaml
tasks:
  - id: each
    type: org.kestra.core.tasks.flows.EachSequential
    value: '["value 1", "value 2", "value 3"]'
    tasks:
      - id: inner
        type: org.kestra.core.tasks.debugs.Return
        format: "{{task.id}}"
  - id: end
    type: org.kestra.core.tasks.debugs.Return
    format: "{{task.id}} > {{outputs.inner.[value 1].value}}"
```
with the format `outputs.TASKID.[VALUE].PROPERTY`. The special bracket `[]` in  `.[VALUE].` enable special chars like space (and can be remove without any special characters)

#### Lookup in current childs tasks tree

Sometime, it can be useful to access to previous outputs on current task tree, for example on
[EachSequential](/plugins/core/tasks/flows/org.kestra.core.tasks.flows.EachSequential.md),
you iterate for a list of value, doing a first tasks (Download a file for example) and
loading previous files to a database.

For this, you can use function `get` :
```yaml
tasks:
  - id: each
    type: org.kestra.core.tasks.flows.EachSequential
    value: '["value 1", "value 2", "value 3"]'
    tasks:
      - id: first
        type: org.kestra.core.tasks.debugs.Return
        format: "{{task.id}}"
      - id: second
        type: org.kestra.core.tasks.debugs.Return
        format: "{{ (get outputs.first taskrun.value).value }}"
  - id: end
    type: org.kestra.core.tasks.debugs.Return
    format: "{{task.id}} > {{outputs.inner.[value 1].value}}"
```

or the function `eval` :
```yaml
tasks:
  - id: each
    type: org.kestra.core.tasks.flows.EachSequential
    value: '["value 1", "value 2", "value 3"]'
    tasks:
      - id: first
        type: org.kestra.core.tasks.debugs.Return
        format: "{{task.id}}"
      - id: second
        type: org.kestra.core.tasks.debugs.Return
        format: "{{ eval 'outputs.first.[{{taskrun.value}}].value' }}"
  - id: end
    type: org.kestra.core.tasks.debugs.Return
    format: "{{task.id}} > {{outputs.inner.[value 1].value}}"
```
