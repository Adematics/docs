---
title: Kestra 0.18 brings Namespaces and KV Store to Open-Source, SCIM to Enterprise and Task Runners to GA!
description: This release adds KV Store, SCIM Directory Sync, Audit Logs and Secrets Enhancements, new capabilities in Task Runners, and improved Namespace Management, now also available in the Open Source version.
date: 2024-08-06T13:00:00
category: News & Products Updates
author:
  name: Anna Geller
  image: ageller
image: /blogs/2024-08-06-release-0-18.png
---

We are thrilled to announce Kestra 0.18.0, which introduces a host of enhancements to both [Open-Source](https://github.com/kestra-io/kestra) and [Enterprise Edition](https://kestra.io/enterprise).

The table below summarizes the highlights of this release.

| Feature              | Enhancement                                                                                                                                                                                                                                           | Edition                          | Docs                                                        |
|----------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|----------------------------------|-------------------------------------------------------------|
| **KV Store**         | Major addition to Kestra's core orchestration capabilities, allowing you to **store and retrieve key-value pairs** in tasks and triggers, enabling a wide range of new use cases and bringing statefulness to otherwise stateless workflow execution. | Both Open-Source and Enterprise  | [Link](/docs/concepts/kv-store)                             |
| **Outputs**      | We've significantly revamped the **Execution Outputs UI** to make it easy to inspect, preview and download your workflow artifacts even across many, often deeply nested outputs.                                                                     | Both Open-Source and Enterprise  | [Link](/docs/workflow-components/outputs)                   |
| **Namespaces** | The new improved Namespace Overview, now available also in the Open Source version, provides a comprehensive view of all namespaces used in your flows without having to create those namespace manually.                                             | Both Open-Source and Enterprise  | [Link](/docs/workflow-components/namespace)                 |
| **Realtime Triggers**    | All realtime triggers are now easier to troubleshoot — you can view their **logs** and **restart** them directly from the UI.                                                                                                                         | Both Open-Source and Enterprise  | [Link](/docs/workflow-components/triggers/realtime-trigger) |
| **Task Runners**         | Task Runners are now out of Beta and ready for production use at scale. The `taskRunner` property can now be used in all script and CLI tasks.                                                                                                        | Both Open-Source and Enterprise  | [Link](/docs/concepts/task-runners)                         |
| **SCIM Directory Sync**  | Enterprise customers can now automate the **synchronization of users and groups** from your Identity Provider (such as Microsoft Entra ID, Okta, authentik or Keycloak) to Kestra.                                                                | Enterprise Edition                  | [Link](/docs/enterprise/scim)                               |
| **Audit Logs**           | Audit Logs have undergone a major overhaul, now including a richer display of changes and enabling new use cases such as filtering executions by users who triggered them.                                                                            | Enterprise Edition                  | [Link](/docs/enterprise/audit-logs)                         |
| **Secrets Handling**     | The **Secrets** handling has been improved, allowing for description and tagging of secrets, and more cost-effective API calls to external secrets managers.                                                                                          | Enterprise Edition                  | [Link](/docs/enterprise/secrets)                            |


If you'd like to see a 2-minute overview of the main new features, check out the release video below:

<div class="video-container">
  <iframe src="https://youtu.be/H9TqNWcrfYA?si=E0tN4Et_tOjklnvj" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
</div>


Let's dive into these enhancements and see how they can benefit your workflows!


## KV Store 🔑

Kestra's workflows are **stateless**. By default, all executions are isolated from each other to avoid any unintended side effects. When you pass data between tasks, you do so explicitly by passing outputs from one task to another and that data is persisted in Kestra's internal storage. This stateless execution model ensures that workflows are **idempotent** and can be **executed anywhere** in parallel, at any scale.

However, in certain scenarios, your workflow might need to share data beyond passing outputs from one task to another. For example, you might want to persist data across executions or even across different workflows. This is where the [new KV Store](https://github.com/kestra-io/kestra/issues/3609) comes in!

This release introduces `KV Store` to bring statefulness to your workflows. KV Store allows you to **persist any data produced in your workflows in a convenient key-value format**, eliminating the need to manage an external database or storage system to persist such data.

You can create new KV pairs directly from the Kestra UI, via dedicated tasks in your flow, via Terraform or via our REST API. Then, you can read any stored `value` by its `key` in any task or trigger with a simple `{{ kv('YOUR_KEY') }}` expression, making it easy to share data across flows and executions.

Since the `KV Store` has been built on top of Kestra's internal storage (which can be any cloud storage service like `S3` or `GCS`):
1. There are **no limits** with respect to the amount of data you can persist for each key — if you need to persist a 1 TB large CSV file to pass it between workflows, no problem! To help you avoid cluttering your storage space with large objects, you can set a custom Time-to-Live (TTL) for any key and Kestra will take care of cleaning up the data for the expired keys.
2. You keep **full control and privacy** over any data stored in Kestra's KV Store as it's persisted within your private Cloud storage bucket.

<div class="video-container">
  <iframe src="https://www.youtube.com/watch?v=CNv_z-tnwnQ&list=PLEK3H8YwZn1pbL_nRKDqE3s7J8os_yc31&index=4" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
</div>

Note that KV Store is a Namespace-level feature — to start adding new KV pairs, navigate to any given `Namespace` and then click on the `KV Store` tab.

::alert{type="info"}
If you are on Enterprise Edition, make sure to add a `KVSTORE` permission to any `Role` that needs access to the KV Store. You need to explicitly add that permission to see the `KV Store` tab in the UI. You can fully customize which Roles can `CREATE`, `READ`, `UPDATE` or `DELETE` KV pairs, and you can restrict those permissions to a specific namespace when needed.
::

Overall, the KV store is a powerful addition to Kestra's orchestration capabilities allowing you to persist state and share data across flows and executions.

Read more about the KV Store in our [Concepts documentation](/docs/concepts/kv-store).

---

## New Namespaces Overview 📊

Before Kestra 0.18.0, the `Namespaces` UI page suffered from the following issues:
1. That page only displayed **existing namespaces** — those explicitly created from the UI or via Terraform. Other namespaces used in flows were displayed in a greyed-out state, which led to confusion among many users.
2. The **hierarchy** of nested namespaces was missing, which made it difficult to understand the parent-child relationships between namespaces.

![namespaces_before_0_18](/blogs/2024-08-06-release-0-18/namespaces_before_0_18.png)

The `Namespaces` page has been [fully redesigned](https://github.com/kestra-io/kestra/issues/3609) in Kestra 0.18.0 to address these issues. You will now see all namespaces used in any flow in a hierarchical structure, including nested child namespaces that can be expanded and collapsed. And we're excited to announce that this feature is now available in the Open Source version as well!

We have also added the `Editor` tab to the `Namespace` page, making it easier to manage [Namespace Files](https://kestra.io/docs/developer-guide/namespace-files) for the relevant namespace.

Here is how the new `Namespaces` overview page looks like in Kestra 0.18.0 (in both Open Source and Enterprise Edition):

![namespaces_after_0_18](/blogs/2024-08-06-release-0-18/namespaces_after_0_18.png)

Here is a detailed page for a Namespace in the Open-Source version — note how the `KV Store` is displayed as one of the Namespace-level tabs:

![namespace_oss](/blogs/2024-08-06-release-0-18/namespace_oss.png)

And here is how the same Namespace page looks like in the Enterprise Edition:

![namespace_ee](/blogs/2024-08-06-release-0-18/namespace_ee.png)

Check the following video demo for a deep dive into the new `Namespaces` UI:

<div class="video-container">
  <iframe src="https://www.youtube.com/watch?v=CNv_z-tnwnQ&list=PLEK3H8YwZn1pbL_nRKDqE3s7J8os_yc31&index=4" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
</div>

---

## SCIM Directory Sync 🗂️

The Enterprise Edition of Kestra now supports Directory Sync Integration via SCIM 2.0 protocol, allowing you to keep your users and groups in sync between your Identity Provider (IdP) and Kestra.

Our SCIM integration allows you to automate provisioning and de-provisioning of users and groups. Instead of manually creating and managing users in Kestra, you can sync them from your IdP via our SCIM API endpoint.

![scim](/blogs/2024-08-06-release-0-18/scim.jpg)

At the time of this release, we have tested and [documented](/docs/enterprise/scim) our SCIM integration with Microsoft Entra ID, Okta, Keycloak, and authentik. If you are using a different IdP or struggle to set up SCIM with Kestra, please reach out to us on our [community Slack](https://kestra.io/slack) for assistance.

---

## Audit Logs Overhaul 🕵️

Our audit logs have undergone a comprehensive refactor in this release, making it easier to track changes and ensuring that all necessary information is captured.

![audit_logs](/blogs/2024-08-06-release-0-18/audit_logs.jpg)

You can now filter Audit Log events created by a specific `User`, and you can also filter by the `Resource` (e.g., `Tenant`, `Namespace`, `Flow`, `Execution`, etc.). This makes it easier to filter for changes you are looking for and troubleshoot issues in your Kestra environment. We've also introduced a couple of new log events, e.g. for Tenant-level changes like Tenant created, renamed or deleted.

Each audit log now additionally includes the information whether a given resource has been `Created`, `Updated` or `Deleted`. And when you need to dive even deeper, click on the `Changes` icon to see a JSON diff of the changes displayed in a similar fashion to the flow revision history.

![audit_logs_diff](/docs/enterprise/audit_logs/audit_logs_diff.gif)

::alert{type="info"}
Note that we now also provide a task to purge old audit logs — the new `io.kestra.plugin.ee.audit.PurgeAuditLogs` task allows you to delete audit logs older than a specified number of days. It's useful for compliance reasons and to keep your database size in check.
::

---

## Secrets Enhancements 🔐

This release has brought additional improvements to our **Secrets** handling, allowing for description and tagging of secrets, and more cost-effective API calls to external secrets managers.

Instead of querying all available secrets in a fast (but potentially costly) manner, Kestra now lists secrets more gradually, starting by querying the flow's namespace (without including parent namespaces). If the requested secret was not found, we search for it one level higher in the namespace hierarchy, and then another level higher, and so on.

To further limit the number of required API calls to the Secrets Manager, we've introduced a new boolean `cache` property in the `kestra.secret` configuration. When enabled, Kestra will cache the secrets, reducing the number of API calls to the secrets manager.

```yaml
kestra:
  secret:
    type: aws-secret-manager
    cache:
      enabled: true # false by default
    aws-secret-manager:
      accessKeyId: mysuperaccesskey
      secretKeyId: mysupersecretkey
      region: us-east-1
```

Apart from the more **cost-effective handling of API calls** to secrets managers, you can now forward kestra-specific `tags` and (_for secrets managers that support it_) a `description` of the secret to the secrets manager.

![secrets_enhancements](/blogs/2024-08-06-release-0-18/secrets_enhancements.png)

Finally, you can add a global configuration to automatically forward some `tags` to all secrets created by Kestra:

```yaml
kestra:
  secret:
    type: aws-secret-manager
    tags:
      managedBy: kestra
      environment: production
```

---

## General Availability of Task Runners 🏃

One of the major highlights of Kestra 0.18.0 is that **Task Runners** are now **out of Beta**!

Task Runners are plugins capable of executing your tasks in remote environments. We introduced task runners in Beta in Kestra 0.16.0, and since then, we've been improving their performance, stability, and usability. Thanks to the feedback from over 80 users and many enhancements and bug fixes, Task Runners are now generally available and ready for production use at scale.

Check the video below for a quick overview of Task Runners:

<div class="video-container">
  <iframe src="https://youtu.be/edYa8WAMAdQ" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
</div>

Below are the main enhancements to Task Runners added in this release:
- The `taskRunner` property has been added to all CLI tasks including `DbtCLI`, `TerraformCLI`, and all other script tasks.
- The `runner` property has been deprecated in favor of the now generally available `taskRunner` property, which provides more flexibility and allows you to run your code in different remote environments, including Kubernetes, AWS Batch, Azure Batch, Google Batch, and more.
- The Docker Task Runner now [uses a volume](https://github.com/kestra-io/kestra/issues/3857) instead of a bind-mount, resolving permission issues with a root user.
- Files added to the `WorkingDirectory` task are [now correctly injected](https://github.com/kestra-io/kestra/issues/4279) into the `taskRunner` container's working directory.
- dbt outputs are [now captured](https://github.com/kestra-io/plugin-dbt/issues/113) across all task runners (though keep in mind that you may need to add `projectDir` and add the `--project-dir dbt/` to your dbt command).
- Killing an Execution will now also stop the remote container created by the Task Runner, ensuring that no compute resources are running unnecessarily.
- We [no longer create a new job](https://github.com/kestra-io/plugin-aws/issues/402) when resubmitting a task with the `AWS`/`Azure`/`Google` Batch task runners. Instead, we now reuse the existing job.
- We [improved](https://github.com/kestra-io/plugin-aws/issues/415) processing of `outputFiles` so that you can now declare which files should be captured as outputs using a simple RegEx expression e.g. `"*.json"`.

Task Runners in 0.18.0 offer a more resilient file handling and more stability when recovering from failure in remote compute environments. Read more about Task Runners in our [Concepts Documentation](../docs/05.concepts/09.task-runners/index.md).

![taskrunner_ga](/blogs/2024-08-06-release-0-18/taskrunner_ga.png)

---

## New Outputs UI 📤

We've heard [your feedback](https://github.com/kestra-io/kestra/issues/1528) that the Outputs UI needed a revamp, and we're excited to announce the new Outputs UI in Kestra 0.18.0!

The Outputs tab now displays Execution outputs in a **multi-column format** with a hierarchical structure, allowing you to **gradually expand nested outputs**, and offering a more intuitive experience when navigating through execution artifacts.

![outputs](/blogs/2024-08-06-release-0-18/outputs.png)

All features such as **Outputs preview** and the ability to **render custom expressions** are still available — the only change here is that the `Render Expressions` button has been renamed to `Debug Outputs`.

---

## Realtime Triggers Enhancements ⚡️

This release introduces several enhancements to Realtime Triggers to make them more observable and easier to troubleshoot. Specifically, you can now view the logs of all Realtime Triggers and restart them directly from the UI.

![realtime_trigger_ui](/blogs/2024-08-06-release-0-18/realtime_trigger_ui.png)

If a `RealtimeTrigger` is misconfigured (e.g. invalid SQS or Kafka credentials), Kestra will now immediately generate a failed Execution with a friendly error message asking you to verify the trigger configuration. You can then correct the misconfigured properties and restart the trigger from the UI.

---

## Other UI Enhancements 🎨

### New Default and Temporal logs display

The UI now provides a new view to display workflow execution **logs**. In addition to the Default view showing logs grouped by a task, you can now switch to a Temporal view showing both task logs and flow logs in a raw timestamp-ordered format. This allows you to see:
1. The exact order of logs as they were emitted during the execution
2. [Additional logs](https://github.com/kestra-io/kestra/issues/2521) not related to any specific task emitted by the Executor e.g. logs related to concurrency limits, errors in flowable or executable tasks, etc.

![temporal_default_logs](/blogs/2024-08-06-release-0-18/temporal_default_logs.png)

The GIF below shows how you can switch between both views:

![temporal_default_logs](/blogs/2024-08-06-release-0-18/temporal.gif)

### Quality of Life Improvements

All subflow executions (those created via a `Subflow` task and those created via `ForEachItem`) now [generate](https://github.com/kestra-io/kestra/issues/2481#issuecomment-2233326952) clickable links to the corresponding subflow and its execution, simplifying the navigation between parent and subflow executions:

![subflow_links](/blogs/2024-08-06-release-0-18/subflow_links.png)

The `Execute` modal now [additionally displays](https://github.com/kestra-io/kestra/issues/3585) a `Copy as cURL` button making it easier to trigger your execution from anywhere:

![execute_curl](/blogs/2024-08-06-release-0-18/execute_curl.png)

---

## New Improved Purge Process 🧹

As your workflows grow, you may need to clean up old executions and logs to avoid running out of disk space.

We've [improved](https://github.com/kestra-io/kestra/pull/4298) the mechanism of the **Purge tasks** to make them more performant and reliable:
- `io.kestra.plugin.core.storage.Purge` has been renamed to `io.kestra.plugin.core.execution.PurgeExecutions` to reflect that it only purges data related to executions (e.g. not including trigger logs, to purge those you should use the `PurgeLogs` task) — we've added an alias so that using the old task type will still work but it will emit a warning. We recommend using the new task type.
- `io.kestra.plugin.core.storage.PurgeExecution` has been renamed to `io.kestra.plugin.core.storage.PurgeCurrentExecutionFiles` — also here, we've added an alias so that using the old task type will still work but it will emit a warning. Again, we recommend adjusting your flow code to match the new task type.

From Kestra 0.18.0 on, the recommended way to clean execution and logs is using a combination of `io.kestra.plugin.core.execution.PurgeExecutions` and the newly added `io.kestra.plugin.core.log.PurgeLogs` task that removes all logs (both Execution logs and Trigger logs) in a performant batch operation. Combining those two together will give you the same functionality as the previous `io.kestra.plugin.core.storage.Purge` task but in a more performant and reliable way (roughly [10x faster](https://github.com/kestra-io/kestra/pull/4298#issuecomment-2220106142)).

```yaml
id: purge
namespace: company.myteam
description: |
  This flow will remove all executions older than one month and all logs older than one month.
  We recommend running this flow daily to avoid running out of disk space and keep the purging operation efficient.

tasks:
  - id: purge_executions
    type: io.kestra.plugin.core.execution.PurgeExecutions
    endDate: "{{ now() | dateAdd(-1, 'MONTHS') }}"
    purgeLog: false

  - id: purge_logs
    type: io.kestra.plugin.core.log.PurgeLogs
    endDate: "{{ now() | dateAdd(-1, 'MONTHS') }}"

triggers:
  - id: daily
    type: io.kestra.plugin.core.trigger.Schedule
    cron: "@daily"
```

If you are an Enterprise Edition customer, we recommend adding the `io.kestra.plugin.ee.audit.PurgeAuditLogs` task allowing you to clean up old audit logs as well.

---

## Enhancements to the Core Tasks 🛠️

### New `ForEach` task

A new `ForEach` core task has been [introduced](https://github.com/kestra-io/kestra/issues/2137) to unify and simplify parallel and sequential task executions, replacing (_in a non-breaking way!_) the `EachParallel` and `EachSequential` tasks. Those old tasks are deprecated but you can still use them — take as much time as you need to migrate.

### New `SELECT` and `MULTISELECT` input types

The new `SELECT` and `MULTISELECT` input types provide a more intuitive and improved functionality over the (now deprecated) `ENUM`-type input. They both allow you to provide a list of values to choose from, with `SELECT` allowing only [one value](https://github.com/kestra-io/kestra/issues/4024) to be selected and `MULTISELECT` allowing [multiple values](https://github.com/kestra-io/kestra/issues/4063) to be selected.

### Improved JSON and ION Handling

We've made [several improvements](https://github.com/kestra-io/kestra/issues/3715) to JSON and ION handling. To avoid confusion between the `json` filter and `json()` function, we've renamed:
1. the `json` filter to `toJson` — it converts an object or data structure into a JSON string e.g. `{{ [1, 2, 3] | toJson  }}`
2. the `json()` function to `fromJson` — it converts a JSON string into a data structure or object so you can access further attributes using a dot notation e.g. `{{ fromJson(kv('YOUR_JSON_KEY')).some_attribute }}`

We've also implemented equivalent functionality for ION — the new `fromIon()` function converts an ION string into a data structure or object.  This function will raise an error if you try to parse a multi-line string (i.e. an ION file with multiple rows) for performance reasons.

The renaming has been implemented in a non-breaking way — using `json()` will raise a warning in the UI but it will still work.

### Support for Unix Cron Expressions

We have added support for standard Unix cron expressions with the `SECOND` field, allowing for more precise scheduling in your workflows.

![second](/blogs/2024-08-06-release-0-18/cron_second.png)

Note that this is a non-breaking change — the `SECOND` field in Unix cron expressions is just an optional extra field that you can use to schedule your executions to run e.g. every 5 seconds by setting the `SECOND` field to `*/5`.

### Improved `null` Handling

We've resolved an issue with the null coalescing operator to ensure it functions correctly when processing both empty (null) and undefined inputs.

Learn more in a dedicated [How-to Guide](/docs/how-to-guides/null-values).


### New Tasks to Manage Namespace Files

We've added new tasks `UploadFiles`, `DownloadFiles`, and `DeleteFiles` allowing you to upload, download and delete your namespace files. Those tasks are primarily intended to help you manage and share code between projects and teams.

For example, you can upload a custom Python script to a specific namespace and execute it from there:

```yaml
id: upload_inputfile
namespace: dev

inputs:
  - id: my_python_script
    type: FILE

tasks:
  - id: upload_and_rename
    type: io.kestra.plugin.core.namespace.UploadFiles
    files:
      /scripts/main.py: "{{ inputs.my_python_script }}"
    namespace: dev

  - id: python
    type: io.kestra.plugin.scripts.python.Commands
    namespaceFiles:
      enabled: true
    commands:
      - python scripts/main.py
```


## New Plugins 🧩

This release adds several new plugins to Kestra's integrations ecosystem, including:
- [MinIO plugin](https://github.com/kestra-io/plugin-minio/pull/2)
- GitHub plugin
- Jira plugin
- Linear plugin
- Apache Airflow plugin (mostly useful for users migrating from Airflow to Kestra).

---

## Next Steps 🚀

This post covered new features and enhancements added in Kestra 0.18.0. Which of them are your favorites? What should we add next? Your feedback is always appreciated.

If you have any questions, reach out via [Slack](https://kestra.io/slack) or open [a GitHub issue](https://github.com/kestra-io/kestra).

If you like the project, give us [a GitHub star](https://github.com/kestra-io/kestra) and join [the community](https://kestra.io/slack).
