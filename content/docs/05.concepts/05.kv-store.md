---
title: Key Value (KV) Store
icon: /docs/icons/concepts.svg
version: ">= 0.18.0"
---

Build stateful workflows with the KV Store.

<div class="video-container">
  <iframe src="https://www.youtube.com/embed/CNv_z-tnwnQ?si=69b0O0fxKESDnQs7" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
</div>

---

## Overview

Kestra's workflows are stateless by design. All workflow executions and task runs are isolated from each other by default to avoid any unintended side effects. When you pass data between tasks, you do so explicitly by passing outputs from one task to another and that data is stored transparently in Kestra's internal storage. This stateless execution model ensures that workflows are idempotent and can be executed anywhere in parallel at scale.

However, in certain scenarios, your workflow might need to share data beyond passing outputs from one task to another. For example, you might want to persist data across executions or even across different workflows. This is where the Key Value (KV) store comes into play.

KV Store allows you to store any data in a convenient key-value format. You can create them directly from the UI, via dedicated tasks, Terraform or through the API.

The KV store is a powerful tool that allows you to build stateful workflows and share data across executions and workflows.

## How KV Store fits into Kestra's architecture

Kestra's architecture has been designed to offer a transparent separation between the orchestration and data processing capabilities. Kestra's [Executor](../07.architecture/04.executor.md) is responsible for executing tasks and workflows without directly interacting with the user's infrastructure. The Executor relies on [Workers](../07.architecture/05.worker.md), which are stateless processes that carry out the computation of runnable tasks and polling triggers. For privacy reasons, workers are the only components that interact with the user's infrastructure, including the internal storage and external services.

Given that data persisted in the KV Store might contain sensitive information, the **KV Store has been built on top of Kestra's internal storage**. This ensures that all values are stored in the your private cloud storage bucket, and Kestra's database only contains metadata about the object, such as the key, file URI, any attached metadata about the object like TTL, creation date, last updated timestamp, etc.

In short, the KV Store gives you full control and privacy over your data, and Kestra only stores metadata about the KV pairs.


## Keys and Values

`Keys` are arbitrary strings. Keys can contain:

* characters in uppercase and or lowercase
* standard ASCII characters

`Values` are stored as ION files in Kestra's internal storage. Values are strongly typed, and can be of one of the following types:

- string
- number
- boolean
- datetime
- date
- duration
- JSON.

For each KV pair, you can set a `Time to Live` (TTL) to avoid cluttering your storage with data that may only be relevant for a limited time.

## Namespace binding

Key value pairs are defined at a namespace level and you can access them from the namespace page in the UI in the KV Store tab.

You can create and read KV pairs across namespaces as long as those namespaces are [allowed](../06.enterprise/allowed-namespaces.md).

## How to create and manage KV pairs

There are multiple ways to create and manage KV pairs:
1. **Kestra UI**: select a Namespace and go to the KV Store tab — from here, you can create, edit, and delete KV pairs.
2. **Task in a flow**: use the `io.kestra.plugin.core.kv.Set`, `io.kestra.plugin.core.kv.Get`, and `io.kestra.plugin.core.kv.Delete` tasks to create, read, and delete KV pairs in a flow.
3. **Kestra's API**: use our HTTP REST API to create, read, and delete KV pairs.
4. **Kestra's Terraform provider**: use the `kestra_kv` resource to create, read, and delete KV pairs.
5. **Pebble function**: use the `kv()` function to retrieve a value by key in a flow.
6. **GitHub Actions**: create, read, and delete KV pairs in your CI/CD pipeline.

The sections below provide detailed instructions on how to create and manage KV pairs using each of these methods.

### Adding new KV pairs from the UI

You can create, edit, and delete KV pairs from the UI in the following way:

1. Navigate to the `Namespaces` page from the left navigation menu and select the namespace where you want to create the KV pair.
  ![navigate_to_namespace](/docs/concepts/kv-store/navigate_to_namespace.png)
2. Go to the `KV Store` tab. This is where you can see all the KV pairs associated with this namespace.
  ![navigate_to_keystore](/docs/concepts/kv-store/navigate_to_keystore.png)
3. Click on `New Key-Value` button in the top right corner to create a new KV pair. Enter a name for the `Key` and assign a suitable `Type` for the value — it can be a string, number, boolean, datetime, date, duration, or JSON.
  ![create_kv_pair](/docs/concepts/kv-store/create_kv_pair.png)
4. Enter the value in the `Value` field.
5. Optionally, you can configure a Time to Live (TTL) for the KV pair. The dropdown contains some standard durations. You can also select `Custom duration` to enter a custom duration as a string in ISO 8601 duration format.
6. Finally, `Save` the changes. Your new KV pair should now be displayed in the list of KV pairs for that namespace.

### Editing and deleting KV pairs from the UI

You can edit or delete any KV pair by clicking on the `Edit` button on the right side of each KV pair.

![edit_delete_kv_pair](/docs/concepts/kv-store/edit_delete_kv_pair.png)

### Adding new KV pairs from a flow

To create a KV pair from a flow, you can use the `io.kestra.plugin.core.kv.Set` task. Here's an example of how to create a KV pair in a flow:

```yaml
id: add_kv_pair
namespace: company.team
tasks:
  - id: query
    type: io.kestra.plugin.core.http.Download
    uri: https://huggingface.co/datasets/kestra/datasets/raw/main/csv/orders.csv

  - id: set_kv
    type: io.kestra.plugin.core.kv.Set
    key: my_key
    value: "{{ outputs.query.uri }}"
    namespace: company.team # the current namespace of the flow is used by default
    overwrite: true # whether to overwrite or fail if a value for that key already exists; default true
    ttl: P30D # optional Time to Live (TTL) for the KV pair
```

You can use set to create or edit the KV pair. Ensure `overwrite` is set to `true` while editing the KV pair.

#### Get the KV pair

The easiest way to retrieve a value by key is to use the Pebble function following this syntax:

```
{{ kv('KEY_NAME', namespace_name, errorOnMissing_boolean) }}
```

For example,

```yaml
tasks:
  - id: log_key
    type: io.kestra.plugin.core.log.Log
    message: "{{ kv('my_key') }}" # assuming you retrieve it in a flow in the same namespace as the one for which key was created
```

If you prefer, you can also retrieve the value using a task:

```yaml
tasks:
  - id: get_value_by_key
    type: io.kestra.plugin.core.kv.Get
    key: my_key
    namespace: company.team # the current namespace of the flow can be used by default
    errorOnMissing: false # bool

  - id: log_key_get
    type: io.kestra.plugin.core.log.Log
    message: "{{ outputs.get_value_by_key.value }}"
```

And if you want to check if some values already exist for a given key, you can search keys by prefix:

```yaml
tasks:
  - id: get_keys_by_prefix
    type: io.kestra.plugin.core.kv.GetKeys
    prefix: "test_"
    namespace: company.team # the current namespace of the flow can be used by default

  - id: log_key_prefix
    type: io.kestra.plugin.core.log.Log
    message: "{{ outputs.get_keys_by_prefix.keys }}"
```

The output will be a list of keys - if no keys were found, an empty list will be returned.

#### Delete a KV pair

The `io.kestra.plugin.core.kv.Delete` task will produce the boolean output `deleted` to confirm it was deleted or not.

```yaml
tasks:
  - id: delete_kv_pair
    type: io.kestra.plugin.core.kv.Delete
    key: my_key
    namespace: company.team # the current namespace of the flow can be used by default
    errorOnMissing: false

  - id: log_kv_deleted
    type: io.kestra.plugin.core.log.Log
    message: "{{ outputs.delete_kv_pair.deleted }}"
```

### Managing KV Store via API

You can manage the KV store via APIs with the following URLs:

#### Set the KV pair

The API call to set the KV pair follows the structure:

```bash
curl -X PUT -H "Content-Type: application/json" http://localhost:8080/api/v1/namespaces/{namespace}/kv/{key} -d '<value>'
```

For example:

```bash
curl -X PUT -H "Content-Type: application/json" http://localhost:8080/api/v1/namespaces/company.team/kv/my_key -d '"Hello World"'
```

The above `curl` call will create the KV pair with key `my_key` with value `Hello World` string in the `company.team` namespace. The API does not return any response as such.

#### Get the KV pair

You can get any particular KV pair using:

```bash
curl -X GET -H "Content-Type: application/json" http://localhost:8080/api/v1/namespaces/{namespace}/kv/{key}
```

For example:

```bash
curl -X GET -H "Content-Type: application/json" http://localhost:8080/api/v1/namespaces/company.team/kv/my_key
```

This would retrieve a KV pair with the key `my_key` in the `company.team` namespace. The output of the API will contain the data type of the value and the retrived value of the KV pair. The output will look like:

```json
{"type": "STRING", "value": "Hello World"}
```

You can also get all the keys in the namespace using the curl call:

```bash
curl -X GET -H "Content-Type: application/json" http://localhost:8080/api/v1/namespaces/{namespace}/kv
```

For example, the following curl call will return all the keys in the `company.team` namespace:

```bash
curl -X GET -H "Content-Type: application/json" http://localhost:8080/api/v1/namespaces/company.team/kv
```

The output will be as follows:
```json
{"key":"my_key","creationDate":"2024-07-15T06:10:33.422Z","updateDate":"2024-07-15T06:11:08.911Z"},{"key":"test_key","creationDate":"2024-07-15T04:37:18.196Z","updateDate":"2024-07-15T04:37:18.196Z"}]
```

#### Delete the KV pair

You can delete the KV paior using the following API:

```bash
curl -X DELETE -H "Content-Type: application/json" http://localhost:8080/api/v1/namespaces/{namespace}/kv/{key}
```

This call returns the boolean indicating whether the key existed for deletion or not.

For example, the following curl call will delete the key `my_key` in the `company.team` namespace:

```bash
curl -X DELETE -H "Content-Type: application/json" http://localhost:8080/api/v1/namespaces/company.team/kv/my_key
```

### Managing KV Store via Terraform

You can manage the KV store via Terraform in the following fashion:

#### Create the KV pair

```
resource "kestra_kv" "new" {
  namespace = "company.team"
  key       = "my_key"
  value     = "Hello Woprld"
  type      = "STRING"
}
```

#### Get the KV pair

```
data "kestra_kv" "new" {
  namespace = "company.team"
  key       = "my_key"
}
```

## Accessing JSON value

For accessing JSON value, you need to use the `json()` function on the retrieved value. This is demonstrated in the following flow:

```yaml
id: kv_json_flow
namespace: company.team

tasks:
  - id: set_json_kv
    type: io.kestra.plugin.core.kv.Set
    key: "my_json_key"
    value: |
      {
        "name": "John Doe",
        "age": 32,
        "address": {
          "city": "Paris",
          "country": "France"
        }
      }
    overwrite: true

  - id: get_json_kv_pebble
    type: io.kestra.plugin.core.log.Log
    message:
      - "Name: {{ json(kv('my_json_key')).name }}"
      - "Age: {{ json(kv('my_json_key')).age }}"
      - "City: {{ json(kv('my_json_key')).address.city }}"

  - id: get_json_kv_task
    type: io.kestra.plugin.core.kv.Get
    key: my_json_key

  - id: get_json_kv_nested_value
    type: io.kestra.plugin.core.log.Log
    message: "Country: {{ json(outputs.get_json_kv_task.value).address.country }}"
```
